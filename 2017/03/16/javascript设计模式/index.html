<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="javascript," />










<meta name="description" content="了解JavaScript设计模式我们需要知道的一些必要知识点闭包
闭包最常用的方式就是返回一个内联函数（何为内联函数？就是在函数内部声明的函数）；
在JavaScript中有作用域和执行环境的问题，在函数内部的变量在函数外部是无法访问的，在函数内部却可以得到全局变量。由于种种原因，我们有时候需要得到函数内部的变量，可是用常规方法是得不到的，这时我们就可以创建一个闭包，用来在外部访问这个变量。
闭包">
<meta property="og:type" content="article">
<meta property="og:title" content="javascript设计模式">
<meta property="og:url" content="http://yoursite.com/2017/03/16/javascript设计模式/index.html">
<meta property="og:site_name" content="supermanbin">
<meta property="og:description" content="了解JavaScript设计模式我们需要知道的一些必要知识点闭包
闭包最常用的方式就是返回一个内联函数（何为内联函数？就是在函数内部声明的函数）；
在JavaScript中有作用域和执行环境的问题，在函数内部的变量在函数外部是无法访问的，在函数内部却可以得到全局变量。由于种种原因，我们有时候需要得到函数内部的变量，可是用常规方法是得不到的，这时我们就可以创建一个闭包，用来在外部访问这个变量。
闭包">
<meta property="og:updated_time" content="2018-02-07T07:24:40.720Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascript设计模式">
<meta name="twitter:description" content="了解JavaScript设计模式我们需要知道的一些必要知识点闭包
闭包最常用的方式就是返回一个内联函数（何为内联函数？就是在函数内部声明的函数）；
在JavaScript中有作用域和执行环境的问题，在函数内部的变量在函数外部是无法访问的，在函数内部却可以得到全局变量。由于种种原因，我们有时候需要得到函数内部的变量，可是用常规方法是得不到的，这时我们就可以创建一个闭包，用来在外部访问这个变量。
闭包">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/16/javascript设计模式/"/>





  <title>javascript设计模式 | supermanbin</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">supermanbin</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/javascript设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="supermanbin">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">javascript设计模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-16T17:03:41+08:00">
                2017-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="了解JavaScript设计模式我们需要知道的一些必要知识点"><a href="#了解JavaScript设计模式我们需要知道的一些必要知识点" class="headerlink" title="了解JavaScript设计模式我们需要知道的一些必要知识点"></a>了解JavaScript设计模式我们需要知道的一些必要知识点</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ol>
<li>闭包最常用的方式就是返回一个<code>内联函数</code>（何为内联函数？就是在函数内部声明的函数）；</li>
<li>在JavaScript中有作用域和执行环境的问题，在函数内部的变量在函数外部是无法访问的，在函数内部却可以得到全局变量。由于种种原因，我们有时候需要得到函数内部的变量，可是用常规方法是得不到的，这时我们就可以创建一个闭包，用来在外部访问这个变量。</li>
<li>闭包的用途 主要就是上一点提到的读取函数内部变量，还有一个作用就是可以使这些变量一直保存在内存中。</li>
<li>使用闭包要注意，由于变量被保存在内存中，所以会对内存造成消耗，所以不能滥用闭包。解决方法是 在退出函数之前，将不使用的局部变量全部删除。<a id="more"></a>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(n+=<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fn1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> result = fn();</div><div class="line">result(); <span class="comment">// 1000</span></div><div class="line">result(); <span class="comment">// 1001</span></div></pre></td></tr></table></figure>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>定义：通过将一个方法或者属性声明为私有的，可以让对象的实现细节对其它对象保密以降低对象之间的耦合度，可以保持数据的完整性并对其修改方式加以约束，这样可以是代码更可靠，更易于调试。封装是面向对象的设计的基石。<br>尽管JavaScript是一门面向对象的语言，可它并不具备将成员声明为公用或私用的任何内部机制，所以我们只能自己想办法实现这种特性。下面还是通过一套完整的代码去分析，介绍什么是==私有属性和方法==，什么是==特权属性和方法==，什么是==公有属性和方法==，什么是==公有静态属性和方法==。</p>
<blockquote>
<p><strong><em>私有属性和方法：</em></strong><br>函数有作用域，在函数内用var关键字声明的变量在外部无法访问，私有属性和方法本质就是你希望在对象外部无法访问的变量。</p>
<p><strong><em>特权属性和方法：</em></strong><br>创建属性和方法时使用的this关键字，因为这些方法定义在构造器的作用域中，所以它们可以访问到私有属性和方法；<br>只有那些需要直接访问私有成员的方法才应该被设计为特权方法。</p>
<p><strong><em>共有属性和方法：</em></strong><br>直接链在prototype上的属性和方法，不可以访问构造器内的私有成员，可以访问特权成员，<em>子类会继承所有的共有方法</em>。</p>
<p><strong><em>共有静态属性和方法：</em></strong><br>最好的理解方式就是把它想象成一个命名空间，实际上相当于把构造器作为命名空间来使用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* -- 封装 -- */</span></div><div class="line">　　<span class="keyword">var</span> _packaging =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="comment">//私有属性和方法</span></div><div class="line">   　　<span class="keyword">var</span> name =<span class="string">'Darren'</span>;</div><div class="line">   　　<span class="keyword">var</span> method1 =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    　　  <span class="comment">//...</span></div><div class="line">   　　&#125;</div><div class="line">   　　<span class="comment">//特权属性和方法</span></div><div class="line">   　　<span class="keyword">this</span>.title =<span class="string">'JavaScript Design Patterns'</span> ;</div><div class="line">   　　<span class="keyword">this</span>.getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    　　  <span class="keyword">return</span> name;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//共有静态属性和方法</span></div><div class="line">　　_packaging._name =<span class="string">'Darren code'</span>;</div><div class="line">　　_packaging.alertName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　alert(_packaging._name);</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//共有属性和方法</span></div><div class="line">　　_packaging.prototype = &#123;</div><div class="line">   　　<span class="attr">init</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      　　<span class="comment">//...</span></div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承本身就是一个抽象的话题，在JavaScript中继承更是一个复杂的话题，因为JavaScript想要实现继承有两种实现方式，分别是类式继承和原型式继承，每种实现的方式都需要采取不少措施，下面本人通过分析例子的方式讲解JavaScript中这个很重要的话题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* -- 类式继承 -- */</span></div><div class="line">　　<span class="comment">//先声明一个超类</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">this</span>.name = name;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//给这个超类的原型对象上添加方法 getName </span></div><div class="line">　　Person.prototype.getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//实例化这个超类</span></div><div class="line">　　<span class="keyword">var</span> a =<span class="keyword">new</span> Person(<span class="string">'Darren1'</span>)</div><div class="line">　　alert(a.getName());</div><div class="line">　　<span class="comment">//再声明类</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params">name,sex</span>)</span>&#123;</div><div class="line">   　　<span class="comment">//这个类中要调用超类Person的构造函数，并将参数name传给它</span></div><div class="line">   　　Person.call(<span class="keyword">this</span>,name);</div><div class="line">   　　<span class="keyword">this</span>.sex = sex;</div><div class="line">　　&#125;</div><div class="line">　 <span class="comment">//这个子类的原型对象等于超类的实例</span></div><div class="line">　　Programmer.prototype =<span class="keyword">new</span> Person();</div><div class="line">　　<span class="comment">//因为子类的原型对象等于超类的实例，所以prototype.constructor这个方法也等于超类构造函数，你可以自己测试一下，如果没这一步，alert(Programmer.prototype.constructor)，这个是Person超类的引用，所以要从新赋值为自己本身</span></div><div class="line">　　Programmer.prototype.constructor = Programmer;</div><div class="line">　　<span class="comment">//子类本身添加了getSex 方法</span></div><div class="line">　　Programmer.prototype.getSex =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="keyword">return</span> <span class="keyword">this</span>.sex;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//实例化这个子类</span></div><div class="line">　　<span class="keyword">var</span> _m =<span class="keyword">new</span> Programmer(<span class="string">'Darren2'</span>,<span class="string">'male'</span>);</div><div class="line">　　<span class="comment">//自身的方法</span></div><div class="line">　　alert(_m.getSex());</div><div class="line">　　<span class="comment">//继承超类的方法</span></div><div class="line">　　alert(_m.getName());</div></pre></td></tr></table></figure>
<p>代码都不难，只要对 原型链 有基础就能理解。类式继承模式是JavaScript继承主要的模式，几乎所有用面向对象方式编写的JavaScript代码中都用到了这种继承，又因为在各种流行语言中只有JavaScript使用原型式继承，因此最好还是使用类式继承。可是要熟悉JavaScript语言，原型继承也是我们必须所了解的，至于在项目中是否使用就得看个人编码风格了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* -- 原型式继承 -- */</span></div><div class="line">　　<span class="comment">//clone()函数用来创建新的类Person对象</span></div><div class="line">　　<span class="keyword">var</span> clone =<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> _f =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">   　　<span class="comment">//这句是原型式继承最核心的地方，函数的原型对象为对象字面量</span></div><div class="line">   　　_f.prototype = obj; </div><div class="line">   　　returnnew _f;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//先声明一个对象字面量</span></div><div class="line">　　<span class="keyword">var</span> Person = &#123;</div><div class="line">   　　<span class="attr">name</span>:<span class="string">'Darren'</span>,</div><div class="line">   　　<span class="attr">getName</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      　　returnthis.name;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//不需要定义一个Person的子类，只要执行一次克隆即可</span></div><div class="line">　　<span class="keyword">var</span> Programmer = clone(Person);</div><div class="line">　　<span class="comment">//可以直接获得Person提供的默认值，也可以添加或者修改属性和方法</span></div><div class="line">　　alert(Programmer.getName())</div><div class="line">　　Programmer.name =<span class="string">'Darren2'</span></div><div class="line">　　alert(Programmer.getName())</div><div class="line"></div><div class="line">　　<span class="comment">//声明子类,执行一次克隆即可</span></div><div class="line">　　<span class="keyword">var</span> Someone = clone(Programmer);</div></pre></td></tr></table></figure>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript设计模式的作用 - 提高代码的重用性，可读性，使代码更容易的维护和扩展。</p>
<blockquote>
<ul>
<li><p><strong>单体模式</strong>，<strong>工厂模式</strong>，<strong>桥梁模式</strong>个人认为这个一个优秀前端必须掌握的模式，对抽象编程和接口编程都非常有好处。</p>
</li>
<li><p><strong>装饰者模式</strong>和<strong>组合模式</strong>有很多相似的地方，它们都与所包装的对象实现同样的接口并且会把任何方法的调用传递给这些对象。<strong>装饰者模式</strong>和<strong>组合模式</strong>是本人描述的较吃力的两个模式，我个人其实也没用过，所以查了很多相关资料和文档，请大家海涵。</p>
</li>
<li><p><strong>门面模式</strong>是个非常有意思的模式，几乎所有的JavaScript库都会用到这个模式，假如你有逆向思维或者逆向编程的经验，你会更容易理解这个模式（听起来有挑战，其实一接触你就知道这是个很简单的模式）；还有<strong>配置器模式</strong>得和<strong>门面模式</strong>一块拿来说，这个模式对现有接口进行包装，合理运用可以很多程度上提高开发效率。这两个模式有相似的地方，所以一块理解的话相信都会很快上手的。</p>
</li>
<li><p><strong>享元模式</strong>是一种以优化为目的的模式。</p>
</li>
<li><p><strong>代理模式</strong>主要用于控制对象的访问，包括推迟对其创建需要耗用大量计算资源的类得实例化。</p>
</li>
<li><p><strong>观察者模式</strong>用于对对象的状态进行观察，并且当它发生变化时能得到通知的方法。用于让对象对事件进行监听以便对其作出响应。<strong>观察者模式</strong>也被称为“<strong>订阅者模式</strong>”。</p>
</li>
<li><p><strong>命令模式</strong>是对方法调用进行封装的方式，用<strong>命名模式</strong>可以对方法调用进行参数化和传递，然后在需要的时候再加以执行</p>
</li>
<li><p><strong>职责链模式</strong>用来消除请求的发送者和接收者之间的耦合。</p>
</li>
</ul>
</blockquote>
<h3 id="单体（Singleton）模式"><a href="#单体（Singleton）模式" class="headerlink" title="单体（Singleton）模式"></a>单体（Singleton）模式</h3><p><strong>绝对是JavaScript中最基本最有用的模式。</strong></p>
<p>单体在JavaScript的有多种用途，<strong>它用来划分命名空间</strong>。可以减少网页中全局变量的数量(在网页中使用全局变量有风险)；可以在多人开发时避免代码的冲突(使用合理的命名空间)等等。</p>
<p>在中小型项目或者功能中，单体可以用作命名空间把自己的代码组织在一个全局变量名下；在稍大或者复杂的功能中，单体可以用来把相关代码组织在一起以便日后好维护。</p>
<p>使用单体的方法就是用一个命名空间包含自己的所有代码的全局对象，示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> functionGroup = &#123;</div><div class="line">　　　　<span class="attr">name</span>:<span class="string">'Darren'</span>,</div><div class="line">　　　　<span class="attr">method1</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//code</span></div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">init</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　<span class="comment">//code</span></div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p><strong>或者</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> functionGroup  =newfunction myGroup()&#123;</div><div class="line">　　　　<span class="keyword">this</span>.name =<span class="string">'Darren'</span>;</div><div class="line">　　　　<span class="keyword">this</span>.getName =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.name</div><div class="line">　　　　&#125;</div><div class="line">　　　　<span class="keyword">this</span>.method1 =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">　　　　...</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<h3 id="工厂（Factory）模式"><a href="#工厂（Factory）模式" class="headerlink" title="工厂（Factory）模式"></a>工厂（Factory）模式</h3><p><strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。</strong></p>
<p>工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(何为耦合？就是相互影响)。<strong>通过使用工厂方法而不是new关键字及具体类</strong>，可以把所有实例化的代码都集中在一个位置，有助于创建模块化的代码，这才是工厂模式的目的和优势。</p>
<p>举个例子：你有一个大的功能要做，其中有一部分是要考虑扩展性的，那么这部分代码就可以考虑抽象出来，当做一个全新的对象做处理。好处就是将来扩展的时候容易维护 - 只需要操作这个对象内部方法和属性，达到了动态实现的目的。非常有名的一个示例 - XHR工厂：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XMLHttpFactory =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;　　　　　　<span class="comment">//这是一个简单工厂模式</span></div><div class="line">　　XMLHttpFactory.createXMLHttp =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　 <span class="keyword">var</span> XMLHttp = <span class="literal">null</span>;</div><div class="line">　　　　<span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)&#123;</div><div class="line">　　　　　　XMLHttp = <span class="keyword">new</span> XMLHttpRequest()</div><div class="line">　　　 &#125;elseif (<span class="built_in">window</span>.ActiveXObject)&#123;</div><div class="line">　　　　　　XMLHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</div><div class="line">　　　　&#125;</div><div class="line">　　<span class="keyword">return</span> XMLHttp;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//XMLHttpFactory.createXMLHttp()这个方法根据当前环境的具体情况返回一个XHR对象。</span></div><div class="line">　　<span class="keyword">var</span> AjaxHander =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> XMLHttp = XMLHttpFactory.createXMLHttp();</div><div class="line">　　　　...</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>工厂模式又区分简单工厂模式和抽象工厂模式，上面介绍的是简单工厂模式，这种模式用的更多也更简单易用。抽象工厂模式的使用方法就是 - 先设计一个抽象类，这个类不能被实例化，只能用来派生子类，最后通过对子类的扩展实现工厂方法。 示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> XMLHttpFactory =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;　     <span class="comment">//这是一个抽象工厂模式</span></div><div class="line">　　XMLHttpFactory.prototype = &#123;</div><div class="line">   　　<span class="comment">//如果真的要调用这个方法会抛出一个错误，它不能被实例化，只能用来派生子类</span></div><div class="line">   　　createFactory:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      　　<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is an abstract class'</span>);</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//派生子类，文章开始处有基础介绍那有讲解继承的模式，不明白可以去参考原理</span></div><div class="line">　　<span class="keyword">var</span> XHRHandler =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　XMLHttpFactory.call(<span class="keyword">this</span>);</div><div class="line">　　&#125;;</div><div class="line">　　XHRHandler.prototype =<span class="keyword">new</span> XMLHttpFactory();</div><div class="line">　　XHRHandler.prototype.constructor = XHRHandler;</div><div class="line">　　<span class="comment">//重新定义createFactory 方法</span></div><div class="line">　　XHRHandler.prototype.createFactory =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="keyword">var</span> XMLHttp =<span class="literal">null</span>;</div><div class="line">   　　<span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)&#123;</div><div class="line">      　　XMLHttp =<span class="keyword">new</span> XMLHttpRequest()</div><div class="line">   　　&#125;elseif (<span class="built_in">window</span>.ActiveXObject)&#123;</div><div class="line">      　　XMLHttp =<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</div><div class="line">   　　&#125;</div><div class="line">   　　<span class="keyword">return</span> XMLHttp;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h3 id="桥接（bridge）模式"><a href="#桥接（bridge）模式" class="headerlink" title="桥接（bridge）模式"></a>桥接（bridge）模式</h3><p><strong>在实现API的时候，桥梁模式灰常有用。在所有模式中，这种模式最容易立即付诸实施。</strong></p>
<p>桥梁模式可以用来弱化它与使用它的类和对象之间的耦合，就是将抽象与其实现隔离开来，以便二者独立变化；这种模式对于JavaScript中常见的时间驱动的编程有很大益处，桥梁模式最常见和实际的应用场合之一是时间监听器回调函数。先分析一个不好的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　<span class="keyword">new</span> setLogFunc();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为什么说这个示例不好，因为从这段代码中无法看出那个LogFunc方法要显示在什么地方，它有什么可配置的选项以及应该怎么去修改它。换一种说法就是，桥梁模式的要诀就是让接口“可桥梁”，实际上也就是可配置。把页面中一个个功能都想象成模块，接口可以使得模块之间的耦合降低。</p>
<p>掌握桥梁模式的正确使用收益的不只是你，还有那些负责维护你代码的人。把抽象于其实现隔离开，可独立地管理软件的各个部分，bug也因此更容易查找。</p>
<p>桥梁模式目的就是让API更加健壮，提高组件的模块化程度，促成更简洁的实现，并提高抽象的灵活性。一个好的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">new</span> someFunc(element, param, callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注：桥梁模式还可以用于连接公开的API代码和私有的实现代码，还可以把多个类连接在一起。在文章封装介绍的部分提到过特权方法，也是桥梁模式的一种特例。《JS设计模式》上找的示例，加深大家对这个模式的理解：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误的方式</span></div><div class="line">　　<span class="comment">//这个API根据事件监听器回调函数的工作机制，事件对象被作为参数传递给这个函数。本例中并没有使用这个参数，而只是从this对象获取ID。</span></div><div class="line">　　addEvent(element,<span class="string">'click'</span>,getBeerById);</div><div class="line">　　<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">var</span> id =<span class="keyword">this</span>.id;</div><div class="line">   　　asyncRequest(<span class="string">'GET'</span>,<span class="string">'beer.url?id='</span>+ id,<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</div><div class="line">      　　<span class="comment">//Callback response</span></div><div class="line">     　　 <span class="built_in">console</span>.log(<span class="string">'Requested Beer: '</span>+ resp.responseText);</div><div class="line">   　　&#125;);</div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　<span class="comment">//好的方式</span></div><div class="line">　　<span class="comment">//从逻辑上分析，把id传给getBeerById函数式合情理的，且回应结果总是通过一个毁掉函数返回。这么理解，我们现在做的是针对接口而不是实现进行编程，用桥梁模式把抽象隔离开来。</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">getBeerById</span>(<span class="params">id,callback</span>)</span>&#123;</div><div class="line">   　　asyncRequest(<span class="string">'GET'</span>,<span class="string">'beer.url?id='</span>+ id,<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>)</span>&#123;</div><div class="line">      　　callback(resp.responseText)</div><div class="line">   　　&#125;);</div><div class="line">　　&#125;</div><div class="line">　　addEvent(element,<span class="string">'click'</span>,getBeerByIdBridge);</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">getBeerByIdBridge</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">   　　getBeerById(<span class="keyword">this</span>.id,<span class="function"><span class="keyword">function</span>(<span class="params">beer</span>)</span>&#123;</div><div class="line">      　　<span class="built_in">console</span>.log(<span class="string">'Requested Beer: '</span>+ beer);</div><div class="line">   　　&#125;);</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h3 id="装饰者（Decorator）模式"><a href="#装饰者（Decorator）模式" class="headerlink" title="装饰者（Decorator）模式"></a>装饰者（Decorator）模式</h3><p><strong>这个模式就是为对象增加功能(或方法)。</strong></p>
<p>动态地给一个对象添加一些额外的职责。就扩展功能而言，它比生成子类方式更为灵活。</p>
<p>装饰者模式和组合模式有很多共同点，它们都与所包装的对象实现统一的接口并且会把任何方法条用传递给这些对象。可是组合模式用于把众多子对象组织为一个整体，而装饰者模式用于在不修改现有对象或从派生子类的前提下为其添加方法。</p>
<p>装饰者的运作过程是透明的，这就是说你可以用它包装其他对象，然后继续按之前使用那么对象的方法来使用，从下面的例子中就可以看出。还是从代码中理解吧：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建一个命名空间为myText.Decorations</span></div><div class="line">　　<span class="keyword">var</span> myText= &#123;&#125;;</div><div class="line">　　myText.Decorations=&#123;&#125;;</div><div class="line">　　myText.Core=<span class="function"><span class="keyword">function</span>(<span class="params">myString</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">this</span>.show =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> myString;&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//第一次装饰</span></div><div class="line">　　myText.Decorations.addQuestuibMark =<span class="function"><span class="keyword">function</span>(<span class="params">myString</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">this</span>.show =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> myString.show()+<span class="string">'?'</span>;&#125;;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//第二次装饰</span></div><div class="line">　　myText.Decorations.makeItalic =<span class="function"><span class="keyword">function</span>(<span class="params">myString</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">this</span>.show =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'&lt;li&gt;'</span>+myString.show()+<span class="string">'&lt;/li&gt;'</span>&#125;;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//得到myText.Core的实例</span></div><div class="line">　　<span class="keyword">var</span> theString =<span class="keyword">new</span> myText.Core(<span class="string">'this is a sample test String'</span>);</div><div class="line">　　alert(theString.show());　　<span class="comment">//output 'this is a sample test String'</span></div><div class="line">　　theString =<span class="keyword">new</span> myText.Decorations.addQuestuibMark(theString);</div><div class="line">　　alert(theString.show());　　<span class="comment">//output 'this is a sample test String?'</span></div><div class="line">　　theString =<span class="keyword">new</span> myText.Decorations.makeItalic (theString);</div><div class="line">　　alert(theString.show());　　<span class="comment">//output '&lt;li&gt;this is a sample test String&lt;/li&gt;'</span></div></pre></td></tr></table></figure></p>
<p>从这个示例中可以看出，这一切都可以不用事先知道组件对象的接口，甚至可以动态的实现，在为现有对象增添特性这方面，装饰者模式有极大的灵活性。</p>
<p>如果需要为类增加特性或者方法，而从该类派生子类的解决办法并不实际的话，就应该使用装饰者模式。派生子类之所以会不实际最常见的原因是需要添加的特性或方法的数量要求使用大量子类。</p>
<h3 id="组合（Composite）模式"><a href="#组合（Composite）模式" class="headerlink" title="组合（Composite）模式"></a>组合（Composite）模式</h3><p><strong>将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</strong></p>
<p>组合模式是一种专为创建Web上的动态用户界面而量身定制的模式。使用这种模式，可以用一条命令在多个对象上激发复杂的或递归的行为。组合模式擅长于对大批对象进行操作。</p>
<p>组合模式的好处：1.程序员可以用同样的方法处理对象的集合与其中的特定子对象；2.它可以用来把一批子对象组织成树形结构，并且使整棵树都可被便利。</p>
<p>组合模式适用范围：1.存在一批组织成某处层次体系的对象（具体结构可能在开发期间无法知道）；2.希望对这批对象或其中的一部分对象实话一个操作。</p>
<p>其实组合模式就是将一系列相似或相近的对象组合在一个大的对象，由这个大对象提供一些常用的接口来对这些小对象进行操作，代码可重用，对外操作简单。例如：对form内的元素，不考虑页面设计的情况下，一般就剩下input了，对于这些input都有name和value的属性，因此可以将这些input元素作为form对象的成员组合起来，form对象提供对外的接口，便可以实现一些简单的操作，比如设置某个input的value，添加/删除某个input等等。</p>
<p>这种模式描述起来比较吃力，我从《JS设计模式》上找个一个实例，大家还是看代码吧：先创建组合对象类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DynamicGallery Class</span></div><div class="line">　　<span class="keyword">var</span> DynamicGallery =<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123; <span class="comment">// 实现Composite，GalleryItem组合对象类 </span></div><div class="line">   　　<span class="keyword">this</span>.children = [];</div><div class="line">   　　<span class="keyword">this</span>.element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">   　　<span class="keyword">this</span>.element.id = id;</div><div class="line">   　　<span class="keyword">this</span>.element.className =<span class="string">'dynamic-gallery'</span>;</div><div class="line">　　&#125;</div><div class="line">　　DynamicGallery.prototype = &#123;</div><div class="line">   　　<span class="comment">// 实现Composite组合对象接口 </span></div><div class="line">   　　add: <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</div><div class="line">      　　<span class="keyword">this</span>.children.push(child);</div><div class="line">      　　<span class="keyword">this</span>.element.appendChild(child.getElement());</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">remove</span>: <span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>&#123;</div><div class="line">      　　<span class="keyword">for</span> (<span class="keyword">var</span> node, i =<span class="number">0</span>; node =<span class="keyword">this</span>.getChild(i); i++) &#123;</div><div class="line">         　　<span class="keyword">if</span> (node == child) &#123;</div><div class="line">            　　<span class="keyword">this</span>.children.splice(i, <span class="number">1</span>);</div><div class="line">           　　 <span class="keyword">break</span>;</div><div class="line">         　　&#125;</div><div class="line">      　　&#125;</div><div class="line">      　　<span class="keyword">this</span>.element.removeChild(child.getElement());</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">getChild</span>: <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</div><div class="line">      　　returnthis.children[i];</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="comment">// 实现DynamicGallery组合对象接口 </span></div><div class="line">   　　hide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      　　<span class="keyword">for</span> (<span class="keyword">var</span> node, i =<span class="number">0</span>; node =<span class="keyword">this</span>.getChild(i); i++) &#123;</div><div class="line">         　　node.hide();</div><div class="line">      　　&#125;</div><div class="line">      　　<span class="keyword">this</span>.element.style.display =<span class="string">'none'</span>;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">show</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      　　<span class="keyword">this</span>.element.style.display =<span class="string">'block'</span>;</div><div class="line">      　　<span class="keyword">for</span> (<span class="keyword">var</span> node, i =<span class="number">0</span>; node = getChild(i); i++) &#123;</div><div class="line">         　　node.show();</div><div class="line">      　　&#125;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="comment">// 帮助方法 </span></div><div class="line">   　　getElement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      　　returnthis.element;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>再创建叶对象类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> GalleryImage =<span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123; <span class="comment">// 实现Composite和GalleryItem组合对象中所定义的方法 </span></div><div class="line">   　　<span class="keyword">this</span>.element = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</div><div class="line">   　　<span class="keyword">this</span>.element.className =<span class="string">'gallery-image'</span>;</div><div class="line">   　　<span class="keyword">this</span>.element.src = src;</div><div class="line">　　&#125;</div><div class="line">　　GalleryImage.prototype = &#123;</div><div class="line">   　　<span class="comment">// 实现Composite接口 </span></div><div class="line">   　　<span class="comment">// 这些是叶结点，所以我们不用实现这些方法，我们只需要定义即可 </span></div><div class="line">   　　add: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</div><div class="line">   　　<span class="attr">remove</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</div><div class="line">   　　<span class="attr">getChild</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;,</div><div class="line">   　　<span class="comment">// 实现GalleryItem接口 </span></div><div class="line">   　　hide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      　　<span class="keyword">this</span>.element.style.display =<span class="string">'none'</span>;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">show</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      　　<span class="keyword">this</span>.element.style.display =<span class="string">''</span>;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="comment">// 帮助方法 </span></div><div class="line">   　　getElement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      　　returnthis.element;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以使用这两个类来管理图片：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> topGallery =<span class="keyword">new</span> DynamicGallery(<span class="string">'top-gallery'</span>); </div><div class="line">　　topGallery.add(<span class="keyword">new</span> GalleryImage(<span class="string">'/img/image-1.jpg'</span>)); </div><div class="line">　　topGallery.add(<span class="keyword">new</span> GalleryImage(<span class="string">'/img/image-2.jpg'</span>)); </div><div class="line">　　topGallery.add(<span class="keyword">new</span> GalleryImage(<span class="string">'/img/image-3.jpg'</span>)); </div><div class="line">　　<span class="keyword">var</span> vacationPhotos =<span class="keyword">new</span> DyamicGallery(<span class="string">'vacation-photos'</span>); </div><div class="line">　　<span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>, i &lt;<span class="number">30</span>; i++)&#123; </div><div class="line">　　　　vacationPhotos.add(<span class="keyword">new</span> GalleryImage(<span class="string">'/img/vac/image-'</span>+ i +<span class="string">'.jpg'</span>)); </div><div class="line">　　&#125; </div><div class="line">　　topGallery.add(vacationPhotos); </div><div class="line">　　topGallery.show(); </div><div class="line">　　vacationPhotos.hide();</div></pre></td></tr></table></figure></p>
<h3 id="门面（facade）模式"><a href="#门面（facade）模式" class="headerlink" title="门面（facade）模式"></a>门面（facade）模式</h3><p><strong>门面模式是几乎所有JavaScript库的核心原则</strong></p>
<p>子系统中的一组接口提供一个一致的界面，门面模式定义了一个高层接口，这个接口使得这一子系统更加容易使用，简单的说这是一种组织性的模式，它可以用来修改类和对象的接口，使其更便于使用。</p>
<p>门面模式的两个作用：1.简化类的接口；2.消除类与使用它的客户代码之间的耦合。</p>
<p>门面模式的使用目的就是图方面。</p>
<p>想象一下计算机桌面上的那些快捷方式图标，它们就是在扮演一个把用户引导至某个地方的接口的角色，每次操作都是间接的执行一些幕后的命令。</p>
<p>你在看这篇的博客的时候我就假设你已经有JavaScript的使用经验了，那么你一定写过或者看过这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> addEvent =<span class="function"><span class="keyword">function</span>(<span class="params">el,type,fn</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</div><div class="line">      　　el.addEventListener(type,fn);</div><div class="line">   　　&#125;elseif(<span class="built_in">window</span>.attachEvent)&#123;</div><div class="line">      　　el.attachEvent(<span class="string">'on'</span>+type,fn);</div><div class="line">   　　&#125;<span class="keyword">else</span>&#123;</div><div class="line">      　　el[<span class="string">'on'</span>+type] = fn;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<p>这个就是一个JavaScript中常见的事件监听器函数，这个函数就是一个基本的门面，有了它，就有了为DOM节点添加事件监听器的简便方法。</p>
<p>现在要说门面模式的精华部分了，为什么说JavaScript库几乎都会用这种模式类。假如现在要设计一个库，那么最好把其中所有的工具元素放在一起，这样更好用，访问起来更简便。看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_model.util是一个命名空间</span></div><div class="line">　　_myModel.util.Event = &#123;</div><div class="line">   　　<span class="attr">getEvent</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">      　　<span class="keyword">return</span> e|| <span class="built_in">window</span>.event;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">getTarget</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">      　　<span class="keyword">return</span> e.target||e.srcElement;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">preventDefault</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">      　　<span class="keyword">if</span>(e.preventDefault)&#123;</div><div class="line">         　　e.preventDefault();</div><div class="line">      　　&#125;<span class="keyword">else</span>&#123;</div><div class="line">         　　e.returnValue =<span class="literal">false</span>;</div><div class="line">      　　&#125;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;;</div><div class="line">　　<span class="comment">//事件工具大概就是这么一个套路，然后结合addEvent函数使用</span></div><div class="line">　　addEvent(<span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>],<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">   　　alert(_myModel.util.Event.getTarget(e));</div><div class="line">　　&#125;);</div></pre></td></tr></table></figure>
<p>个人认为，在处理游览器差异问题时最好的解决办法就是把这些差异抽取的门面方法中，这样可以提供一个更一致的接口，addEvent函数就是一个例子。 </p>
<h3 id="适配置器（Adapter）模式"><a href="#适配置器（Adapter）模式" class="headerlink" title="适配置器（Adapter）模式"></a>适配置器（Adapter）模式</h3><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作，使用这种模式的对象又叫包装器，因为他们是在用一个新的接口包装另一个对象。</p>
<p>从表面上看，它和门面模式有点相似，差别在于它们如何改变接口，门面模式展现的是一个简化的接口，它并不提供额外的选择，而适配器模式则要把一个接口转换为另一个接口，它并不会滤除某些能力，也不会简化接口。先来一个简单的示例看看：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//假如有一个3个字符串参数的函数，但是现在拥有的却是一个包含三个字符串元素的对象，那么就可以用一个配置器来衔接二者</span></div><div class="line">　　<span class="keyword">var</span> clientObject = &#123;</div><div class="line">   　　<span class="attr">str1</span>:<span class="string">'bat'</span>,</div><div class="line">   　　<span class="attr">str2</span>:<span class="string">'foo'</span>,</div><div class="line">   　　<span class="attr">str3</span>:<span class="string">'baz'</span></div><div class="line">　　&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">interfaceMethod</span>(<span class="params">str1,str2,str3</span>)</span>&#123;</div><div class="line">　　　　alert(str1)</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//配置器函数</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">adapterMethod</span>(<span class="params">o</span>)</span>&#123;</div><div class="line">   　　interfaceMethod(o.str1, o.str2, o.str3);</div><div class="line">　　&#125;</div><div class="line">　　adapterMethod(clientObject)</div><div class="line">　　<span class="comment">//adapterMethod函数的作为就在于对interfaceMethod函数进行包装，并把传递给它的参数转换为后者需要的形式。</span></div></pre></td></tr></table></figure>
<p>适配器模式的工作机制是：用一个新的接口对现有类得接口进行包装。</p>
<p>示例：适配两个库。下面的例子要实现的是从Prototype库的$函数到YUI的get方法的转换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先看它们在接口方面的差别</span></div><div class="line">　　<span class="comment">//Prototype $ function </span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">$</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="keyword">var</span> elements =<span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">   　　<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</div><div class="line">      　　<span class="keyword">var</span> element = <span class="built_in">arguments</span>[i];</div><div class="line">      　　<span class="keyword">if</span>(<span class="keyword">typeof</span> element ==<span class="string">'string'</span>)&#123;</div><div class="line">         　　element = <span class="built_in">document</span>.getElementById(element);</div><div class="line">      　　&#125;</div><div class="line">      　　<span class="keyword">if</span>(<span class="keyword">typeof</span>.length ==<span class="number">1</span>)    <span class="keyword">return</span> element;</div><div class="line">      　　elements.push(element);</div><div class="line">   　　&#125;</div><div class="line">   　　<span class="keyword">return</span> elements;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//YUI get method</span></div><div class="line">　　YAHOO.util.Dom.get =<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">if</span>(YAHOO.lang.isString(el))&#123;</div><div class="line">      　　<span class="keyword">return</span> <span class="built_in">document</span>.getElementById(el);</div><div class="line">   　　&#125;</div><div class="line">   　　<span class="keyword">if</span>(YAHOO.lang.isArray(el))&#123;</div><div class="line">      　　<span class="keyword">var</span> c =[];</div><div class="line">      　　<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=el.length;i&lt;len;++i)&#123;</div><div class="line">         　　c[c.length] = YAHOO.util.Dom.get(el[i]);</div><div class="line">      　　&#125;</div><div class="line">      　　<span class="keyword">return</span> c;</div><div class="line">   　　&#125;</div><div class="line">   　　<span class="keyword">if</span>(el)&#123;</div><div class="line">      　　<span class="keyword">return</span> el;</div><div class="line">   　　&#125;</div><div class="line">   　　returnnull;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//二者区别就在于get具有一个参数，且可以是HTML,字符串或者数组；而$木有正是的参数，允许使用者传入任意数目的参数，不管HTML还是字符串。</span></div><div class="line">　　<span class="comment">//如果需要从使用Prototype的$函数改为使用YUI的get方法（或者相反，那么用适配器模式其实很简单）</span></div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">PrototypeToYUIAdapter</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="keyword">return</span> YAHOO.util.Dom.get(<span class="built_in">arguments</span>);</div><div class="line">　　&#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">YUIToPrototypeAdapter</span>(<span class="params">el</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">return</span> $.apply(<span class="built_in">window</span>,el <span class="keyword">instanceof</span> <span class="built_in">Array</span>?el:[el]);</div><div class="line">　　&#125;</div></pre></td></tr></table></figure>
<h3 id="享元（Flyweight）模式"><a href="#享元（Flyweight）模式" class="headerlink" title="享元（Flyweight）模式"></a>享元（Flyweight）模式</h3><p><strong>运用共享技术有效地支持大量细粒度的对象。</strong></p>
<p><strong>享元模式可以避免大量非常相似类的开销。在程序设计中有时需要生成大量细粒度的类实例来表示数据。如果发现这些实例除了几个参数外基本伤都是相同的，有时就能够受大幅度第减少需要实例化的类的数量。如果能把这些参数移到类实例外面，在方法调用时将他们传递进来，就可以通过共享大幅度地减少单个实例的数目。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">组成部分</div><div class="line">　　“享元”：抽离出来的外部操作和数据；</div><div class="line">　　“工厂”：创造对象的工厂；</div><div class="line">　　“存储器”：存储实例对象的对象或数组，供“享元”来统一控制和管理。</div><div class="line"></div><div class="line">　　应用场景</div><div class="line">　　1. 页面存在大量资源密集型对象；</div><div class="line">　　2. 这些对象具备一定的共性，可以抽离出公用的操作和数据</div><div class="line"></div><div class="line">　　关键</div><div class="line">　　1. 合理划分内部和外部数据。</div><div class="line">　　既要保持每个对象的模块性、保证享元的独立、可维护，又要尽可能多的抽离外部数据。</div><div class="line">　　2. 管理所有实例</div><div class="line">　 既然抽离出了外部数据和操作，那享元就必须可以访问和控制实例对象。在JavaScript这种动态语言中，这个需求是很容易实现的：我们可以把工厂生产出的对象简单的扔在一个数组中。为每个对象设计暴露给外部的方法，便于享元的控制。</div><div class="line"></div><div class="line">　　优点</div><div class="line">　　1. 将能耗大的操作抽离成一个，在资源密集型系统中，可大大减少资源和内存占用；</div><div class="line">　　2. 职责封装，这些操作独立修改和维护；</div><div class="line"></div><div class="line">　　缺点</div><div class="line">　 1. 增加了实现复杂度。</div><div class="line">　　将原本由一个工厂方法实现的功能，修改为了一个享元+一个工厂+一个存储器。</div><div class="line">　　2. 对象数量少的情况，可能会增大系统开销。</div></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//汽车登记示例</span></div><div class="line">　　<span class="keyword">var</span> Car =<span class="function"><span class="keyword">function</span>(<span class="params">make,model,year,owner,tag,renewDate</span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">this</span>.make=make;</div><div class="line">　　　　<span class="keyword">this</span>.model=model;</div><div class="line">　　　　<span class="keyword">this</span>.year=year;</div><div class="line">　　　　<span class="keyword">this</span>.owner=owner;</div><div class="line">　　　　<span class="keyword">this</span>.tag=tag;</div><div class="line">　　　　<span class="keyword">this</span>.renewDate=renewDate;</div><div class="line">　　&#125;</div><div class="line">　　Car.prototype = &#123;</div><div class="line">　　　　<span class="attr">getMake</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.make;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">getModel</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.model;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">getYear</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.year;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">transferOwner</span>:<span class="function"><span class="keyword">function</span>(<span class="params">owner,tag,renewDate</span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">this</span>.owner=owner;</div><div class="line">　　　　　　<span class="keyword">this</span>.tag=tag;</div><div class="line">　　　　　　<span class="keyword">this</span>.renewDate=renewDate;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">renewRegistration</span>:<span class="function"><span class="keyword">function</span>(<span class="params">renewDate</span>)</span>&#123;</div><div class="line">　　　　　　<span class="keyword">this</span>.renewDate=renewDate;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//数据量小到没多大的影响，数据量大的时候对计算机内存会产生压力，下面介绍享元模式优化后</span></div><div class="line">　　<span class="comment">//包含核心数据的Car类</span></div><div class="line">　　<span class="keyword">var</span> Car=<span class="function"><span class="keyword">function</span>(<span class="params">make,model,year</span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">this</span>.make=make;</div><div class="line">　　　　<span class="keyword">this</span>.model=model;</div><div class="line">　　　　<span class="keyword">this</span>.year=year;</div><div class="line">　　&#125;</div><div class="line">　　Car.prototype=&#123;</div><div class="line">　　　　<span class="attr">getMake</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.make;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">getModel</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.model;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　<span class="attr">getYear</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　　　returnthis.year;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　<span class="comment">//中间对象，用来实例化Car类</span></div><div class="line">　　<span class="keyword">var</span> CarFactory=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> createdCars = &#123;&#125;;</div><div class="line">　　　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　　　<span class="attr">createCar</span>:<span class="function"><span class="keyword">function</span>(<span class="params">make,model,year</span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">var</span> car=createdCars[make+<span class="string">"-"</span>+model+<span class="string">"-"</span>+year];</div><div class="line">　　　　　　　　<span class="keyword">return</span> car ? car : createdCars[make +<span class="string">'-'</span>+ model +<span class="string">'-'</span>+ year] =(<span class="keyword">new</span> Car(make,model,year));</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;)();</div><div class="line">　　<span class="comment">//数据工厂，用来处理Car的实例化和整合附加数据</span></div><div class="line">　　<span class="keyword">var</span> CarRecordManager = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">　　　　<span class="keyword">var</span> carRecordDatabase = &#123;&#125;;</div><div class="line">　　　　<span class="keyword">return</span> &#123;</div><div class="line">　　　　　　<span class="attr">addCarRecord</span>:<span class="function"><span class="keyword">function</span>(<span class="params">make,model,year,owner,tag,renewDate</span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">var</span> car = CarFactory.createCar(make, model, year);</div><div class="line">　　　　　　　　carRecordDatabase[tag]=&#123;</div><div class="line">　　　　　　　　　　<span class="attr">owner</span>:owner,</div><div class="line">　　　　　　　　　　<span class="attr">tag</span>:tag,</div><div class="line">　　　　　　　　　　<span class="attr">renewDate</span>:renewDate,</div><div class="line">　　　　　　　　　　<span class="attr">car</span>:car</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;,</div><div class="line">　　　　　　<span class="attr">transferOwnership</span>:<span class="function"><span class="keyword">function</span>(<span class="params">tag, newOwner, newTag, newRenewDate</span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">var</span> record=carRecordDatabase[tag];</div><div class="line">　　　　　　　　record.owner = newOwner;</div><div class="line">　　　　　　　　record.tag = newTag;</div><div class="line">　　　　　　　　record.renewDate = newRenewDate;</div><div class="line">　　　　　　&#125;,</div><div class="line">　　　　　　<span class="attr">renewRegistration</span>:<span class="function"><span class="keyword">function</span>(<span class="params">tag,newRenewDate</span>)</span>&#123;</div><div class="line">　　　　　　　　carRecordDatabase[tag].renewDate=newRenewDate;</div><div class="line">　　　　　　&#125;,</div><div class="line">　　　　　　<span class="attr">getCarInfo</span>:<span class="function"><span class="keyword">function</span>(<span class="params">tag</span>)</span>&#123;</div><div class="line">　　　　　　　　<span class="keyword">return</span> carRecordDatabase[tag];</div><div class="line">　　　　　　&#125;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;)();</div></pre></td></tr></table></figure>
<h3 id="代理（Proxy）模式"><a href="#代理（Proxy）模式" class="headerlink" title="代理（Proxy）模式"></a>代理（Proxy）模式</h3><p><strong>此模式最基本的形式是对访问进行控制。代理对象和另一个对象（本体）实现的是同样的接口，可是实际上工作还是本体在做，它才是负责执行所分派的任务的那个对象或类，代理对象不会在另以对象的基础上修改任何方法，也不会简化那个对象的接口。</strong></p>
<p><strong>举一个具体的情况：如果那个对象在某个远端服务器上，直接操作这个对象因为网络速度原因可能比较慢，那我们可以先用Proxy来代替那个对象。</strong></p>
<p><strong>总之对于开销较大的对象，只有在使用它时才创建，这个原则可以为我们节省很多内存。《JS设计模式》上的图书馆示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Publication =<span class="keyword">new</span> Interface(<span class="string">'Publication'</span>, [<span class="string">'getIsbn'</span>, <span class="string">'setIsbn'</span>, <span class="string">'getTitle'</span>, <span class="string">'setTitle'</span>, <span class="string">'getAuthor'</span>, <span class="string">'setAuthor'</span>, <span class="string">'display'</span>]);</div><div class="line">　 <span class="keyword">var</span> Book =<span class="function"><span class="keyword">function</span>(<span class="params">isbn, title, author</span>) </span>&#123;</div><div class="line">   　　 <span class="comment">//...</span></div><div class="line">　　&#125; </div><div class="line">　　<span class="comment">// implements Publication</span></div><div class="line">　　implements(Book,Publication);</div><div class="line"></div><div class="line">　　<span class="comment">/* Library interface. */</span></div><div class="line">　　<span class="keyword">var</span> Library =<span class="keyword">new</span> Interface(<span class="string">'Library'</span>, [<span class="string">'findBooks'</span>, <span class="string">'checkoutBook'</span>, <span class="string">'returnBook'</span>]);</div><div class="line"></div><div class="line">　　<span class="comment">/* PublicLibrary class. */</span></div><div class="line">　　<span class="keyword">var</span> PublicLibrary =<span class="function"><span class="keyword">function</span>(<span class="params">books</span>) </span>&#123;</div><div class="line">   　　 <span class="comment">//...</span></div><div class="line">　　&#125;;</div><div class="line">　　<span class="comment">// implements Library</span></div><div class="line">　　implements(PublicLibrary,Library); </div><div class="line"></div><div class="line">　　PublicLibrary.prototype = &#123;</div><div class="line">   　　 <span class="attr">findBooks</span>: <span class="function"><span class="keyword">function</span>(<span class="params">searchString</span>) </span>&#123;</div><div class="line">      　　 <span class="comment">//...</span></div><div class="line">    　　&#125;,</div><div class="line">    　　<span class="attr">checkoutBook</span>: <span class="function"><span class="keyword">function</span>(<span class="params">book</span>) </span>&#123;</div><div class="line">     　　   <span class="comment">//...</span></div><div class="line">   　　 &#125;,</div><div class="line">    　　<span class="attr">returnBook</span>: <span class="function"><span class="keyword">function</span>(<span class="params">book</span>) </span>&#123;</div><div class="line">      　　  <span class="comment">//...</span></div><div class="line">   　　 &#125;</div><div class="line">　　&#125;;</div><div class="line"></div><div class="line">　　<span class="comment">/* PublicLibraryProxy class, a useless proxy. */</span></div><div class="line">　　<span class="keyword">var</span> PublicLibraryProxy =<span class="function"><span class="keyword">function</span>(<span class="params">catalog</span>) </span>&#123; </div><div class="line">  　　  <span class="keyword">this</span>.library =<span class="keyword">new</span> PublicLibrary(catalog);</div><div class="line">　　&#125;;</div><div class="line">　　<span class="comment">// implements Library</span></div><div class="line">　　implements(PublicLibraryProxy,Library);</div><div class="line"></div><div class="line">　　PublicLibraryProxy.prototype = &#123;</div><div class="line">  　　  <span class="attr">findBooks</span>: <span class="function"><span class="keyword">function</span>(<span class="params">searchString</span>) </span>&#123;</div><div class="line">    　　    returnthis.library.findBooks(searchString);</div><div class="line">    　　&#125;,</div><div class="line">    　　<span class="attr">checkoutBook</span>: <span class="function"><span class="keyword">function</span>(<span class="params">book</span>) </span>&#123;</div><div class="line">     　　   returnthis.library.checkoutBook(book);</div><div class="line">   　　 &#125;,</div><div class="line">   　　 <span class="attr">returnBook</span>: <span class="function"><span class="keyword">function</span>(<span class="params">book</span>) </span>&#123;</div><div class="line">    　　    returnthis.library.returnBook(book);</div><div class="line">   　　 &#125;</div><div class="line">　　&#125;;</div></pre></td></tr></table></figure>
<h3 id="观察者（Observer）模式"><a href="#观察者（Observer）模式" class="headerlink" title="观察者（Observer）模式"></a>观察者（Observer）模式</h3><p><strong>定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。</strong></p>
<p><strong>观察者模式中存在两个角色,观察者和被观察者。在DOM的编程环境中的高级事件模式中，==事件监听器说到底就是一种内置的观察者==。事件处理器(handler)和时间监听器(listener)并不是一回事，前者就是一种把事件传给与其关联的函数的手段，而在后者中，一个时间可以与几个监听器关联，每个监听器都能独立于其他监听器而改变。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用时间监听器可以让多个函数相应一个事件</span></div><div class="line">　　<span class="keyword">var</span> fn1 =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="comment">//code</span></div><div class="line">　　&#125;</div><div class="line">　　<span class="keyword">var</span> fn2 =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   　　<span class="comment">//code</span></div><div class="line">　　&#125;</div><div class="line">　　addEvent(element,<span class="string">'click'</span>,fn1)；</div><div class="line">　　addEvent(element,<span class="string">'click'</span>,fn2)</div><div class="line"></div><div class="line">　 <span class="comment">//而时间处理函数就办不到</span></div><div class="line">　　element.onclick = fn1;</div><div class="line">　　element.onclick = fn2;</div></pre></td></tr></table></figure>
<p>观察者模式是开发基于行为的应用程序的有力手段，前端程序员可做的就是借助一个事件监听器替你处理各种行为，从而降低内存消耗和提高互动性能。</p>
<h3 id="命令（Command）模式"><a href="#命令（Command）模式" class="headerlink" title="命令（Command）模式"></a>命令（Command）模式</h3><p><strong>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</strong></p>
<p><strong>命令对象是一个操作和用来调用这个操作的对象的结合体，所有的命名对象都有一个执行操作，其用途就是调用命令对象所绑定的操作。示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">car Calculator=&#123;</div><div class="line">   　　<span class="attr">add</span>:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    　　  <span class="keyword">return</span> x+y;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">substract</span>:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    　　  <span class="keyword">return</span> x-y;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">multiply</span>:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    　　  <span class="keyword">return</span> x*y;</div><div class="line">   　　&#125;,</div><div class="line">   　　<span class="attr">divide</span>:<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">    　　  <span class="keyword">return</span> x/y;</div><div class="line">   　　&#125;</div><div class="line">　　&#125;</div><div class="line">　　Calculator.calc =<span class="function"><span class="keyword">function</span>(<span class="params">command</span>)</span>&#123;</div><div class="line">   　　<span class="keyword">return</span> Calculator[command.type](command.op1,command.opd2)</div><div class="line">　　&#125;;</div><div class="line">　　Calculator.calc(&#123;<span class="attr">type</span>:<span class="string">'add'</span>,<span class="attr">op1</span>:<span class="number">1</span>,<span class="attr">op2</span>:<span class="number">1</span>&#125;);</div><div class="line">　　Calculator.calc(&#123;<span class="attr">type</span>:<span class="string">'substract'</span>,<span class="attr">op1</span>:<span class="number">5</span>,<span class="attr">op2</span>:<span class="number">2</span>&#125;);</div><div class="line">　　Calculator.calc(&#123;<span class="attr">type</span>:<span class="string">'multiply'</span>,<span class="attr">op1</span>:<span class="number">5</span>,<span class="attr">op2</span>:<span class="number">2</span>&#125;);</div><div class="line">　　Calculator.calc(&#123;<span class="attr">type</span>:<span class="string">'divide'</span>,<span class="attr">op1</span>:<span class="number">8</span>,<span class="attr">op2</span>:<span class="number">4</span>&#125;);</div></pre></td></tr></table></figure>
<p>命名模式的主要用途是把调用对象（用户界面，API和代理等）与实现操作的对象隔离开，也就是说使对象间的互动方式需要更高的模块化时都可以用到这种模式。</p>
<h3 id="职责链（Chain-Of-Responsibility）模式"><a href="#职责链（Chain-Of-Responsibility）模式" class="headerlink" title="职责链（Chain Of Responsibility）模式"></a>职责链（Chain Of Responsibility）模式</h3><p><strong>为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</strong></p>
<p><strong>职责链由多个不同类型的对象组成：发送者是发出请求的对象，而接收者则是接收请求并且对其进行处理或传递的对象，请求本身有时也是一个对象，它封装着与操作有关的所有数据。</strong></p>
<p><strong>典型的流程大致是：</strong></p>
<ul>
<li>发送者知道链中第一个接收者，它向这个接收者发出请求。</li>
<li>每一个接收者都对请求进行分析，然后要么处理它，要么将其往下传。</li>
<li>每一个接收者知道的其他对象只有一个，即它在链中的下家。</li>
<li>如果没有任何接收者处理请求，那么请求将从链上离开，不同的实现对此也有不同的反应，一般会抛出一个错误。</li>
</ul>
<p><strong>职责链模式的适用范围</strong></p>
<ul>
<li>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定；</li>
<li>想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；</li>
<li>可处理一个请求的对象集合需要被动态指定。</li>
</ul>
<p><a href="http://www.cnblogs.com/Darren_code/archive/2011/08/31/JavascripDesignPatterns.html" target="_blank" rel="external">原文地址</a></p>
<p><a href="http://www.cnblogs.com/aaronjs/p/3444874.html" target="_blank" rel="external">解密jQuery事件核心 - 绑定设计（一）</a></p>
<p><a href="https://segmentfault.com/a/1190000006667581" target="_blank" rel="external">理解Javascript中的事件绑定与事件委托</a></p>
<p><a href="http://web.jobbole.com/83642/" target="_blank" rel="external">深入浅出妙用 Javascript 中 apply、call、bind</a></p>
<p><a href="http://www.codeceo.com/article/jquery-plugin-develop.html" target="_blank" rel="external">jQuery插件开发模式详解</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/javascript/" rel="tag"># javascript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/07/JavaScript的实例化与继承：请停止使用new关键字/" rel="prev" title="JavaScript的实例化与继承：请停止使用new关键字">
                JavaScript的实例化与继承：请停止使用new关键字 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fengbin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#了解JavaScript设计模式我们需要知道的一些必要知识点"><span class="nav-number">1.</span> <span class="nav-text">了解JavaScript设计模式我们需要知道的一些必要知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">1.1.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#封装"><span class="nav-number">1.2.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.3.</span> <span class="nav-text">继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正文"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">2.1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单体（Singleton）模式"><span class="nav-number">2.1.1.</span> <span class="nav-text">单体（Singleton）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂（Factory）模式"><span class="nav-number">2.1.2.</span> <span class="nav-text">工厂（Factory）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桥接（bridge）模式"><span class="nav-number">2.1.3.</span> <span class="nav-text">桥接（bridge）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰者（Decorator）模式"><span class="nav-number">2.1.4.</span> <span class="nav-text">装饰者（Decorator）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合（Composite）模式"><span class="nav-number">2.1.5.</span> <span class="nav-text">组合（Composite）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#门面（facade）模式"><span class="nav-number">2.1.6.</span> <span class="nav-text">门面（facade）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适配置器（Adapter）模式"><span class="nav-number">2.1.7.</span> <span class="nav-text">适配置器（Adapter）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#享元（Flyweight）模式"><span class="nav-number">2.1.8.</span> <span class="nav-text">享元（Flyweight）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理（Proxy）模式"><span class="nav-number">2.1.9.</span> <span class="nav-text">代理（Proxy）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察者（Observer）模式"><span class="nav-number">2.1.10.</span> <span class="nav-text">观察者（Observer）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命令（Command）模式"><span class="nav-number">2.1.11.</span> <span class="nav-text">命令（Command）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#职责链（Chain-Of-Responsibility）模式"><span class="nav-number">2.1.12.</span> <span class="nav-text">职责链（Chain Of Responsibility）模式</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fengbin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
